use strict;
use warnings;
use Cwd(qw(abs_path getcwd));

#========================================================================
# 'move.pl' updates the name/path of masterFile and all files generated by masterFile
#========================================================================

#========================================================================
# define variables
#------------------------------------------------------------------------
use vars qw(%options $qDataDir $masterFile $masterFileName $statusFile %statusFields $archiveDir);
my ($newMasterDir, $newMasterFileName, $newMasterFile, $newQDataDir);
#========================================================================

#========================================================================
# main execution block
#------------------------------------------------------------------------
sub qMove {
    checkLock();
    my $queryMessage = "'q move' will change the path of masterFile and update all files created by masterFile";
    getPermission($queryMessage) or exit;
    parseMoveTo();
    print "moving:\n  $masterFile\nto:\n  $newMasterFile\n";
    moveStatusFileLines();
    qx|mv $masterFile $newMasterFile|;  # execute the move
    qx|mv $masterFile.lock $newMasterFile.lock 2>/dev/null|;
    qx|mv $qDataDir $newQDataDir|;
    print "done\n";
}
#========================================================================

#========================================================================
# move execution subroutines
#------------------------------------------------------------------------
sub parseMoveTo {  # learn from move-to option where the user wants masterFile to go
    my $moveTo = $options{'move-to'};
    my $usage ="option '--move-to' must be either:\n  an existing directory, or\n  a path to a non-existent destination file\n";
    if(-d $moveTo){  # request is to move masterFile as is to a new directory
        $newMasterDir = abs_path($moveTo);
        $newMasterFileName = $masterFileName;
    } elsif(-e $moveTo){  # q move won't overwrite a file
        die "$moveTo already exists but is not a directory\n$usage";
    } elsif($moveTo =~ m|(.+)/(.+)$|) {  # request includes a path to a new file
        ($newMasterDir, $newMasterFileName) = ($1, $2);
        -d $newMasterDir or die "$newMasterDir is not a valid directory\n$usage";
        $newMasterDir = abs_path($newMasterDir);
    } else {  # request is a just a new file name in the current path
        $newMasterDir = getcwd();
        $newMasterFileName = $moveTo;
    }
    $newMasterFile = "$newMasterDir/$newMasterFileName";
    $newMasterFile eq $masterFile and die "destination is the same as the source masterFile\n$usage";
    $newQDataDir = "$newMasterDir/.$newMasterFileName.data";
}
sub moveStatusFileLines {  # fix line within status files that depend on current masterFile name/path
    foreach my $sFile($statusFile, glob "$archiveDir/$masterFileName.status.*"){  # include all archives
        open my $statusFileH, "<", $sFile or die "could not open $sFile for reading: $!\n";
        my @newStatusLines;
        while (my $line = <$statusFileH>){
            chomp $line;
            my @line = split("\t", $line);
            $line[0] or next;
            $line[$statusFields{targetScript}] and $line[$statusFields{targetScript}] =~ s/$qDataDir/$newQDataDir/;
            $line[$statusFields{instrsFile}] and $line[$statusFields{instrsFile}] eq $masterFile and $line[$statusFields{instrsFile}] = $newMasterFile;
            push @newStatusLines, join("\t", @line);
        }
        close $statusFileH;
        my $newSFile = $sFile;  # write modified status lines to renamed status file
        $newSFile =~ s/$masterFileName\.status/$newMasterFileName\.status/;
        open $statusFileH, ">", $newSFile or die "could not open $newSFile for writing: $!\n";
        print $statusFileH join("\n", @newStatusLines),"\n";
        close $statusFileH;
        $newSFile eq $sFile or unlink $sFile;
    }
}
#========================================================================

1;

